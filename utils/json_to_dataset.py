import csv
import os
import math
import uuid
import json

import numpy as np

import PIL.Image
import PIL.ImageDraw

from utils.fileio import verify_dir, files_of_type


def shape_to_mask(img_shape, points, shape_type=None,
                  line_width=10, point_size=5):
    """
    Converts a fundamental shape from a labelme file to a mask.

    Directly copied from labelme.utils: https://github.com/wkentaro/labelme
    Eliminates full dependency on labelme

    Parameters
    ----------
    img_shape: tuple
        The (height, width) of the image
    points: list
        List of points making up the shape
    shape_type: str
        Type of the shape
    line_width: int
        Width of the line (used only for certain types)
    point_size: ing
        Size of point, used only for certain types

    Returns
    -------
    mask: np.array
        the image mask
    """
    mask = np.zeros(img_shape[:2], dtype=np.uint8)
    mask = PIL.Image.fromarray(mask)
    draw = PIL.ImageDraw.Draw(mask)
    xy = [tuple(point) for point in points]
    if shape_type == "circle":
        assert len(xy) == 2, "Shape of shape_type=circle must have 2 points"
        (cx, cy), (px, py) = xy
        d = math.sqrt((cx - px) ** 2 + (cy - py) ** 2)
        draw.ellipse([cx - d, cy - d, cx + d, cy + d], outline=1, fill=1)
    elif shape_type == "rectangle":
        assert len(xy) == 2, "Shape of shape_type=rectangle must have 2 points"
        draw.rectangle(xy, outline=1, fill=1)
    elif shape_type == "line":
        assert len(xy) == 2, "Shape of shape_type=line must have 2 points"
        draw.line(xy=xy, fill=1, width=line_width)
    elif shape_type == "linestrip":
        draw.line(xy=xy, fill=1, width=line_width)
    elif shape_type == "point":
        assert len(xy) == 1, "Shape of shape_type=point must have 1 points"
        cx, cy = xy[0]
        r = point_size
        draw.ellipse([cx - r, cy - r, cx + r, cy + r], outline=1, fill=1)
    else:
        assert len(xy) > 2, "Polygon must have points more than 2"
        draw.polygon(xy=xy, outline=1, fill=1)
    mask = np.array(mask, dtype=bool)
    return mask


def shapes_to_label(img_shape, shapes, label_name_to_value):
    """
    Directly copied from labelme.utils: https://github.com/wkentaro/labelme
    Eliminates full dependency on labelme

    Parameters
    ----------
    img_shape: tuple
        The (height, width) of the image
    shapes:
    label_name_to_value: dict
        a dict connecting polygon label names to the numeric id that should be
        displayed in the output array

    Returns
    -------
    cls: np.array
        binary mask image
    ins: np.array
        mask of instance ids for each shape

    """
    cls = np.zeros(img_shape[:2], dtype=np.int32)
    ins = np.zeros_like(cls)
    instances = []
    for shape in shapes:
        points = shape["points"]
        label = shape["label"]
        group_id = shape.get("group_id")
        if group_id is None:
            group_id = uuid.uuid1()
        shape_type = shape.get("shape_type", None)

        cls_name = label
        instance = (cls_name, group_id)

        if instance not in instances:
            instances.append(instance)
        ins_id = instances.index(instance) + 1
        cls_id = label_name_to_value[cls_name]

        mask = shape_to_mask(img_shape[:2], points, shape_type)
        cls[mask] = cls_id
        ins[mask] = ins_id

    return cls, ins


def labelme_json_to_binary(json_file, mask_dir, label_name_to_value,
                           img_ext="png", overwrite=False):
    """
    Adapted from labelme.cli.json_to_dataset
            - https://github.com/wkentaro/labelme

    Takes a JSON file generated by labelme and converts it to a binary image
    mask representing the location of objects labelled in the image.

    Parameters
    ----------
    json_file: str
        Path to the labelme generated JSON shape file.
    mask_dir: str
        Full path to the file output directory. Output will be PNG file
    label_name_to_value: dict
        a dict connecting polygon label names to the numeric id that should be
        displayed in the output array
    img_ext: str (default "png")
        str of the file extension for the output image.
    overwrite: bool (default False)
        If output file exists, should the operation be run anyway?
    """
    if mask_dir is None:
        out_dir = os.path.basename(json_file).replace(".", "_")
        out_dir = os.path.join(os.path.dirname(json_file), out_dir)
    else:
        out_dir = mask_dir

    # Generate the output directory and filename
    verify_dir(out_dir)
    out_fn = os.path.basename(json_file).replace(".json", "." + img_ext)
    out_fn = os.path.join(out_dir, out_fn)
    if os.path.exists(out_fn):
        if not overwrite:
            print("Mask file exists: skipping.")
            return
        else:
            os.remove(out_fn)

    data = json.load(open(json_file))
    imshape = (data['imageHeight'], data['imageWidth'])

    # Create numeric label values for any labels not in label_name_to_value
    value_pairs = label_name_to_value.copy()  # copy to avoid altering
    for shape in sorted(data["shapes"], key=lambda x: x["label"]):
        label_name = shape["label"]
        if label_name not in value_pairs:
            label_value = len(value_pairs)
            value_pairs[label_name] = label_value

    # Convert shapes to mask
    lbl, _ = shapes_to_label(imshape, data["shapes"], value_pairs)
    lbl_pil = PIL.Image.fromarray(lbl.astype(np.uint8), mode="P")

    # Generate the output filename
    lbl_pil.save(out_fn)


def cal_to_labelme(img_list, dataset_json, dataset_csv):
    """
    Convert shape notation files from the California dataset to labelme shape
    files.

    Cal dataset at:
    https://figshare.com/articles/dataset/Distributed_Solar_Photovoltaic_Array_Location_and_Extent_Data_Set_for_Remote_Sensing_Object_Identification/3385780/1?file=5286613

    Parameters
    ----------
    dataset_json: str
        Location of "SolarArrayPolygons.json" file. Contains all poly vertices.
    dataset_csv: str
        Location of "polygonDataExceptVertices.csv". Contains a more quickly
        searchable map between filename and polygon info.
    img_list: list
        A list of filenames of the images to process

    Returns
    -------

    """
    imname_col = 9
    rawnumcol = 0
    idcol = 1

    width = height = None

    with open(dataset_json) as f:
        data = json.load(f)['polygons']

    # data is the polygon info, which is keyed by
    # data[rownum] gets the entry
    # data[rownum]['polygon_id'] is the id
    # data[rownum]['polygon_vertices_pixels'] is the shape

    for imname in img_list:
        imname_base = os.path.basename(imname)

        # Search the CSV file for polygons that go with this image. Extract the
        # polygon row number and ID number.
        poly_nums = []
        poly_ids = []
        with open(dataset_csv) as f:
            rd = csv.reader(f)
            for row in rd:
                if row[imname_col] == os.path.splitext(imname_base)[0]:
                    poly_nums.append(int(row[rawnumcol]))
                    poly_ids.append(int(row[idcol]))

        # Use the extracted polygon info from the CSV to get the vertices from
        # the JSON file. Build into a list of polygons
        shapes = []
        for poly_num, poly_id in zip(poly_nums, poly_ids):
            assert data[poly_num]["polygon_id"] == poly_id
            this_shape = data[poly_num]['polygon_vertices_pixels']
            if np.size(this_shape) > 4:  # Must have more than 2 pts
                shapes.append(this_shape)

        # Build a labelme compatible dict for each shape.
        shapelist = []
        for shape in shapes:
            shapedata = {
                "label": "pv",
                "points": shape,
                "group_id": None,
                "shape_type": "polygon",
                "flags": {}
            }
            shapelist.append(shapedata)

        # Get the image dimensions if they haven't been set yet
        if width is None or height is None:
            with PIL.Image.open(imname) as im:
                width, height = im.size

        # Create a labelme json and insert all the data. Save it.
        json_file = imname.replace(".png", ".json")
        with open(json_file, "w") as file:
            labelme_json = {
                "version": "5.0.1",
                "flags": {},
                "shapes": shapelist,
                "imagePath": imname_base,
                "imageData": None,
                "imageHeight": height,
                "imageWidth": width
            }
            json_str = json.dumps(labelme_json, indent=2)
            file.write(json_str)


# Example directories to test
target_dir = 'C:\\nycdata\\boro_queens_sp18_png\\'
ot_dir = 'C:\\nycdata\\boro_queens_sp18_out\\'

if __name__ == "__main__":
    # label_id_dict = {"_background_": 0, "maybe": 0, "notpv": 0, "pv": 255}
    #
    # for fn in files_of_type(target_dir, "*.json"):
    #     labelme_json_to_binary(fn, ot_dir, label_id_dict)

    label_id_dict = {"_background_": 0, "maybe": 0, "notpv": 0, "pv": 255}
    tst = r"D:\datasets\PV Aerial\NY\img\002200.json"
    ot_dir = r"d:\tst"
    labelme_json_to_binary(tst, ot_dir, label_id_dict)