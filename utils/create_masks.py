import math
import uuid
import os
import glob
import json

import numpy as np
import PIL.Image
import PIL.ImageDraw


def shape_to_mask(img_shape, points, shape_type=None,
                  line_width=10, point_size=5):
    """
    Converts a single fundamental shape from a labelme file to a mask array

    Directly copied from labelme.utils: https://github.com/wkentaro/labelme
    Reproduced here to eliminate dependency on entire labelme package

    Parameters
    ----------
    img_shape: tuple
        The (height, width) of the image
    points: list
        List of points making up the shape
    shape_type: str
        Type of the shape
    line_width: int
        Width of the line (used only for certain types)
    point_size: ing
        Size of point, used only for certain types

    Returns
    -------
    mask: np.array
        the image mask
    """
    mask = np.zeros(img_shape[:2], dtype=np.uint8)
    mask = PIL.Image.fromarray(mask)
    draw = PIL.ImageDraw.Draw(mask)
    xy = [tuple(point) for point in points]
    if shape_type == "circle":
        assert len(xy) == 2, "Shape of shape_type=circle must have 2 points"
        (cx, cy), (px, py) = xy
        d = math.sqrt((cx - px) ** 2 + (cy - py) ** 2)
        draw.ellipse([cx - d, cy - d, cx + d, cy + d], outline=1, fill=1)
    elif shape_type == "rectangle":
        assert len(xy) == 2, "Shape of shape_type=rectangle must have 2 points"
        draw.rectangle(xy, outline=1, fill=1)
    elif shape_type == "line":
        assert len(xy) == 2, "Shape of shape_type=line must have 2 points"
        draw.line(xy=xy, fill=1, width=line_width)
    elif shape_type == "linestrip":
        draw.line(xy=xy, fill=1, width=line_width)
    elif shape_type == "point":
        assert len(xy) == 1, "Shape of shape_type=point must have 1 points"
        cx, cy = xy[0]
        r = point_size
        draw.ellipse([cx - r, cy - r, cx + r, cy + r], outline=1, fill=1)
    else:
        assert len(xy) > 2, "Polygon must have points more than 2"
        draw.polygon(xy=xy, outline=1, fill=1)
    mask = np.array(mask, dtype=bool)
    return mask


def shapes_to_label(img_shape, shapes, label_name_to_value, layer_order=None):
    """
    Convert a group of labelme shapes to a mask array

    Modified from labelme.utils: https://github.com/wkentaro/labelme
        Adds ability to sort by layer order. Important in our case where
        we want to ensure that NOTPV is always drawn after PV. - 2025

    Parameters
    ----------
    img_shape: tuple
        The (height, width) of the image
    shapes:
    label_name_to_value: dict
        a dict connecting polygon label names to the numeric id that should be
        displayed in the output array
    layer_order: list (default None)
        A list of the layer order using the keys in label_name_to_value.
        Must match keys in label_name_to_value. If None, uses numeric value to sort

    Returns
    -------
    cls: np.array
        binary mask image
    ins: np.array
        mask of instance ids for each shape

    """

    if layer_order is None:
        # Default to increasing numeric value
        layer_order = sorted(label_name_to_value.keys(),
                             key=lambda x: label_name_to_value[x])
    else:
        # Check to make sure all keys exist. If they don't, insert as bottom layers.
        for key in label_name_to_value.keys():
            if key not in layer_order:
                layer_order.insert(0, key)

    cls = np.zeros(img_shape[:2], dtype=np.int32)
    ins = np.zeros_like(cls)
    instances = []
    for shape in sorted(shapes, key=lambda x: layer_order.index(x["label"])):
        points = shape["points"]
        label = shape["label"]
        group_id = shape.get("group_id")
        if group_id is None:
            group_id = uuid.uuid1()
        shape_type = shape.get("shape_type", None)

        cls_name = label
        instance = (cls_name, group_id)

        if instance not in instances:
            instances.append(instance)
        ins_id = instances.index(instance) + 1
        cls_id = label_name_to_value[cls_name]

        mask = shape_to_mask(img_shape[:2], points, shape_type)
        cls[mask] = cls_id
        ins[mask] = ins_id

    return cls, ins


def labelme_json_to_binary(json_file, mask_dir, label_name_to_value,
                           layer_order=None,
                           img_ext="png", overwrite=False):
    """
    Convert an entire JSON file to a binary mask image

    Adapted from labelme.cli.json_to_dataset
            - https://github.com/wkentaro/labelme
        Adds ability to apply a layer order for overlapping polygons. - 2025

    Takes a JSON file generated by labelme and converts it to a binary image
    mask representing the location of objects labelled in the image.

    Parameters
    ----------
    json_file: str
        Path to the labelme generated JSON shape file.
    mask_dir: str
        Full path to the file output directory. Output will be PNG file
    label_name_to_value: dict
        a dict connecting polygon label names to the numeric id that should be
        displayed in the output array
    layer_order: list
        A list of the layer order using the keys in label_name_to_value.
        Must match keys in label_name_to_value. If None, uses numeric value to sort
    img_ext: str (default "png")
        str of the file extension for the output image.
    overwrite: bool (default False)
        If output file exists, should the operation be run anyway?
    """
    if mask_dir is None:
        out_dir = os.path.basename(json_file).replace(".", "_")
        out_dir = os.path.join(os.path.dirname(json_file), out_dir)
    else:
        out_dir = mask_dir

    # Generate the output directory and filename
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    out_fn = os.path.basename(json_file).replace(".json", "." + img_ext)
    out_fn = os.path.join(out_dir, out_fn)
    if os.path.exists(out_fn):
        if not overwrite:
            print("Mask file exists: skipping.")
            return
        else:
            os.remove(out_fn)

    data = json.load(open(json_file))
    imshape = (data['imageHeight'], data['imageWidth'])

    # Create numeric label values for any labels not in label_name_to_value
    value_pairs = label_name_to_value.copy()  # copy to avoid altering
    for shape in sorted(data["shapes"], key=lambda x: x["label"]):
        label_name = shape["label"]
        if label_name not in value_pairs:
            label_value = len(value_pairs)
            value_pairs[label_name] = label_value

    # Convert shapes to mask
    lbl, _ = shapes_to_label(imshape, data["shapes"], value_pairs, layer_order)
    lbl_pil = PIL.Image.fromarray(lbl.astype(np.uint8), mode="P")

    # Generate the output filename
    lbl_pil.save(out_fn)



if __name__ == "__main__":
    jsondir = r"path/to/jsonfiles"
    maskdir = r"path/to/mask/output"

    label_id_dict = {"_background_": 0, "notpv": 0, "pv": 255}
    layer_order = ["pv", "notpv"]

    for fn in glob.glob(os.path.join(jsondir, "*.json")):
        labelme_json_to_binary(fn, maskdir, label_id_dict, layer_order=layer_order)